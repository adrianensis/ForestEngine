#include "App.h"
#include "Log.h"

#include <vulkan/vulkan.h>

// The glm/gtc/matrix_transform.hpp header exposes functions that can be used to generate model transformations like glm::rotate, view transformations like glm::lookAt and projection transformations like glm::perspective.
// The GLM_FORCE_RADIANS definition is necessary to make sure that functions like glm::rotate use radians as arguments, to avoid any possible confusion.
// #define GLM_FORCE_RADIANS

// The perspective projection matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default.
// We need to configure it to use the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition.
// #define GLM_FORCE_DEPTH_ZERO_TO_ONE

// #include <glm/glm.hpp>
// #include <glm/gtc/matrix_transform.hpp>

// #define STB_IMAGE_IMPLEMENTATION
// #include <stb_image.h>

#define TINYOBJLOADER_IMPLEMENTATION
// #include <tiny_obj_loader.h>

#include <chrono>
#include <unordered_map>

namespace GPUAPI {

    const uint32_t MAX_FRAMES_IN_FLIGHT = 2;

    App::App(Config config)
            : config(std::move(config)),
              fileSystem(new FileSystem),
              window(new Window(config.mWindow)),
              vulkan(new Vulkan(config.mVulkan, window)),
              vulkanPhysicalDevice(new GPUPhysicalDevice(vulkan)),
              vulkanDevice(new GPUDevice(vulkan, vulkanPhysicalDevice)),
              vulkanCommandPool(new GPUCommandPool(vulkanPhysicalDevice, vulkanDevice)),
              vulkanDepthImage(new GPUImage(vulkanPhysicalDevice, vulkanDevice)),
              vulkanColorImage(new GPUImage(vulkanPhysicalDevice, vulkanDevice)),
              vulkanTextureImage(new GPUImage(vulkanPhysicalDevice, vulkanDevice)),
              vertexShader(new GPUShader(vulkanDevice)),
              fragmentShader(new GPUShader(vulkanDevice)),
              vulkanVertexBuffer(new GPUVertexBuffer(vulkanPhysicalDevice, vulkanDevice, vulkanCommandPool)),
              vulkanIndexBuffer(new GPUIndexBuffer(vulkanPhysicalDevice, vulkanDevice, vulkanCommandPool)),
              vulkanSwapChain(new GPUSwapChain(vulkanDevice, vulkanPhysicalDevice, vulkan, window)),
              vulkanRenderPass(new GPURenderPass(vulkanSwapChain, vulkanDevice, vulkanPhysicalDevice)),
              vulkanGraphicsPipeline(new GPUGraphicsPipeline(vulkanRenderPass, vulkanSwapChain, vulkanDevice, vulkanPhysicalDevice)) {
    }

    App::~App() {
        delete vulkanGraphicsPipeline;
        delete vulkanRenderPass;
        delete vulkanSwapChain;
        delete vulkanIndexBuffer;
        delete vulkanVertexBuffer;
        delete fragmentShader;
        delete vertexShader;
        delete vulkanTextureImage;
        delete vulkanColorImage;
        delete vulkanDepthImage;
        delete vulkanCommandPool;
        delete vulkanDevice;
        delete vulkanPhysicalDevice;
        delete vulkan;
        delete window;
        delete fileSystem;
    }

    void App::run() {
        if (!initialize()) {
            VD_LOG_CRITICAL("Could not initialize app");
            return;
        }
        VD_LOG_INFO("Running...");
        while (!window->shouldClose()) {
            window->pollEvents();
            update();
            drawFrame();
        }
        vulkanDevice->waitUntilIdle();
        terminate();
    }

    bool App::initialize() {
        // Log::initialize(config.Name, config.LogLevel);
        VD_LOG_INFO("Initializing...");

        if (!window->initialize()) {
            VD_LOG_ERROR("Could not initialize window");
            return false;
        }
        window->setOnResize([this](int width, int height) {
            this->windowResized = true;
        });
        window->setOnMinimize([this](bool minimized) {
            this->windowResized = true;
        });

        if (!vulkan->initialize()) {
            VD_LOG_ERROR("Could not initialize Vulkan");
            return false;
        }
        if (!vulkanPhysicalDevice->initialize()) {
            VD_LOG_ERROR("Could not initialize Vulkan physical device");
            return false;
        }
        if (!vulkanDevice->initialize()) {
            VD_LOG_ERROR("Could not initialize Vulkan device");
            return false;
        }
        if (!vulkanSwapChain->initialize()) {
            VD_LOG_ERROR("Could not initialize Vulkan swap chain");
            return false;
        }
        if (!vulkanRenderPass->initialize()) {
            VD_LOG_ERROR("Could not initialize Vulkan render pass");
            return false;
        }
        if (!vulkanCommandPool->initialize()) {
            VD_LOG_ERROR("Could not initialize Vulkan command pool");
            return false;
        }
        if (!vertexShader->initialize(fileSystem->readBytes("shaders/simple_shader.vert.spv"))) {
            VD_LOG_ERROR("Could not initialize vertex shader");
            return false;
        }
        if (!fragmentShader->initialize(fileSystem->readBytes("shaders/simple_shader.frag.spv"))) {
            VD_LOG_ERROR("Could not initialize fragment shader");
            return false;
        }
        if (!initializeDescriptorSetLayout()) {
            VD_LOG_ERROR("Could not initialize Vulkan descroptor set layout");
            return false;
        }
        if (!vulkanGraphicsPipeline->initialize(*vertexShader, *fragmentShader, descriptorSetLayout)) {
            VD_LOG_ERROR("Could not initialize Vulkan graphics pipeline");
            return false;
        }
        if (!initializeColorResources()) {
            VD_LOG_ERROR("Could not initialize color resources");
            return false;
        }
        if (!initializeDepthResources()) {
            VD_LOG_ERROR("Could not initialize depth resources");
            return false;
        }
        if (!initializeFramebuffers()) {
            VD_LOG_ERROR("Could not initialize Vulkan framebuffers");
            return false;
        }
        if (!initializeTextureImage()) {
            VD_LOG_ERROR("Could not initialize texture image");
            return false;
        }
        if (!initializeTextureImageView()) {
            VD_LOG_ERROR("Could not initialize texture image view");
            return false;
        }
        if (!initializeTextureSampler()) {
            VD_LOG_ERROR("Could not initialize texture image sampler");
            return false;
        }
        if (!loadModel()) {
            VD_LOG_ERROR("Could not load 3D model");
            return false;
        }
        if (!vulkanVertexBuffer->initialize(vertices)) {
            VD_LOG_ERROR("Could not initialize Vulkan vertex buffer");
            return false;
        }
        if (!vulkanIndexBuffer->initialize(indices)) {
            VD_LOG_ERROR("Could not initialize Vulkan index buffer");
            return false;
        }
        vulkanCommandBuffers = vulkanCommandPool->allocateCommandBuffers(MAX_FRAMES_IN_FLIGHT);
        if (vulkanCommandBuffers.empty()) {
            VD_LOG_ERROR("Could not initialize Vulkan command buffers");
            return false;
        }
        if (!initializeUniformBuffers()) {
            VD_LOG_ERROR("Could not initialize Vulkan uniform buffers");
            return false;
        }
        if (!initializeDescriptorPool()) {
            VD_LOG_ERROR("Could not initialize Vulkan descriptor pool");
            return false;
        }
        if (!initializeDescriptorSets()) {
            VD_LOG_ERROR("Could not initialize Vulkan descroptor sets");
            return false;
        }
        if (!initializeSyncObjects()) {
            VD_LOG_ERROR("Could not create Vulkan sync objects (semaphores & fences)");
            return false;
        }
        return true;
    }

    bool App::loadModel() {
        /*
         * An OBJ file consists of positions, normals, texture coordinates and faces.
         * Faces consist of an arbitrary amount of vertices, where each vertex refers to a position, normal and/or texture coordinate by index.
         * The attrib container holds all of the positions, normals and texture coordinates in its attrib.vertices, attrib.normals and attrib.texcoords vectors.
         * The shapes container contains all of the separate objects and their faces.
         * Each face consists of an array of vertices, and each vertex contains the indices of the position, normal and texture coordinate attributes.
         */
        // tinyobj::attrib_t attrib;
        // std::vector<tinyobj::shape_t> shapes;
        // std::vector<tinyobj::material_t> materials;
        // std::string error;

        // if (!tinyobj::LoadObj(&attrib, &shapes, &materials, &error, MODEL_PATH.c_str())) {
        //     VD_LOG_ERROR("Could not load .obj file: {}", error);
        //     return false;
        // }

        // std::unordered_map<Vertex, uint32_t> uniqueVertices{};
        // for (const tinyobj::shape_t& shape : shapes) {
        //     for (const tinyobj::index_t& index : shape.mesh.indices) {

        //         Vertex vertex{};
        //         vertex.color = {1.0f, 1.0f, 1.0f};

        //         // Unfortunately the attrib.vertices array is an array of float values instead of something like Vector3, so we need to multiply the index by 3.
        //         vertex.position = {
        //                 attrib.vertices[3 * index.vertex_index + 0],
        //                 attrib.vertices[3 * index.vertex_index + 1],
        //                 attrib.vertices[3 * index.vertex_index + 2]
        //         };
        //         // Similarly, there are two texture coordinate components per entry.
        //         vertex.texCoord = {
        //                 attrib.texcoords[2 * index.texcoord_index + 0],
        //                 // The OBJ format assumes a coordinate system where a vertical coordinate of 0 means the bottom of the image,
        //                 // however we've uploaded our image into Vulkan in a top to bottom orientation where 0 means the top of the image.
        //                 // This can be solved by flipping the vertical component of the texture coordinates
        //                 1.0f - attrib.texcoords[2 * index.texcoord_index + 1]
        //         };
        //         // The offsets of 0, 1 and 2 are used to access the X, Y and Z components,
        //         // or the U and V components in the case of texture coordinates.

        //         if (uniqueVertices.count(vertex) == 0) {
        //             uniqueVertices[vertex] = (uint32_t) vertices.size();
        //             vertices.push_back(vertex);
        //         }
        //         indices.push_back(uniqueVertices[vertex]);
        //     }
        // }
        // VD_LOG_INFO("Loaded .obj file");
        return true;
    }

    bool App::initializeColorResources() {
        VkFormat colorFormat = vulkanSwapChain->getSurfaceFormat().format;

        GPUImage::Config colorImageConfig{};
        colorImageConfig.Width = vulkanSwapChain->getExtent().width;
        colorImageConfig.Height = vulkanSwapChain->getExtent().height;
        colorImageConfig.MipLevels = 1;
        colorImageConfig.SampleCount = vulkanPhysicalDevice->getSampleCount();
        colorImageConfig.Format = colorFormat;
        colorImageConfig.Tiling = VK_IMAGE_TILING_OPTIMAL;
        colorImageConfig.Usage = VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
        colorImageConfig.MemoryProperties = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;

        if (!vulkanColorImage->initialize(colorImageConfig)) {
            VD_LOG_ERROR("Could not initialize color image");
            return false;
        }
        colorImageView = createImageView(vulkanColorImage->getVkImage(), colorFormat, VK_IMAGE_ASPECT_COLOR_BIT, colorImageConfig.MipLevels);
        return true;
    }

    bool App::initializeDepthResources() {
        VkFormat depthFormat = findDepthFormat();

        GPUImage::Config depthImageConfig{};
        depthImageConfig.Width = vulkanSwapChain->getExtent().width;
        depthImageConfig.Height = vulkanSwapChain->getExtent().height;
        depthImageConfig.Format = depthFormat;
        depthImageConfig.Tiling = VK_IMAGE_TILING_OPTIMAL;
        depthImageConfig.Usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT;
        depthImageConfig.MemoryProperties = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
        depthImageConfig.MipLevels = 1;
        depthImageConfig.SampleCount = vulkanPhysicalDevice->getSampleCount();

        if (!vulkanDepthImage->initialize(depthImageConfig)) {
            VD_LOG_ERROR("Could not initialize depth image");
            return false;
        }
        depthImageView = createImageView(vulkanDepthImage->getVkImage(), depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT, depthImageConfig.MipLevels);
        transitionImageLayout(vulkanDepthImage->getVkImage(), depthFormat, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, depthImageConfig.MipLevels);
        return true;
    }

    VkFormat App::findDepthFormat() {
        std::vector<VkFormat> candidates = {
                VK_FORMAT_D32_SFLOAT,
                VK_FORMAT_D32_SFLOAT_S8_UINT,
                VK_FORMAT_D24_UNORM_S8_UINT
        };
        VkImageTiling tiling = VK_IMAGE_TILING_OPTIMAL;
        VkFormatFeatureFlags features = VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT;
        return vulkanPhysicalDevice->findSupportedFormat(candidates, tiling, features);
    }

    bool App::hasStencilComponent(VkFormat format) const {
        return format == VK_FORMAT_D32_SFLOAT_S8_UINT || format == VK_FORMAT_D24_UNORM_S8_UINT;
    }

    bool App::initializeTextureSampler() {
        VkSamplerCreateInfo samplerInfo{};
        samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
        samplerInfo.magFilter = VK_FILTER_LINEAR;
        samplerInfo.minFilter = VK_FILTER_LINEAR;
        samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
        samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
        samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
        samplerInfo.anisotropyEnable = VK_TRUE;
        samplerInfo.maxAnisotropy = vulkanPhysicalDevice->getProperties().limits.maxSamplerAnisotropy;
        samplerInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
        samplerInfo.unnormalizedCoordinates = VK_FALSE;
        samplerInfo.compareEnable = VK_FALSE;
        samplerInfo.compareOp = VK_COMPARE_OP_ALWAYS;
        samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
        samplerInfo.mipLodBias = 0.0f;
        samplerInfo.minLod = 0.0f;
        samplerInfo.maxLod = (float) mipLevels;

        VkAllocationCallbacks* allocationCallbacks = VK_NULL_HANDLE;
        if (vkCreateSampler(vulkanDevice->getDevice(), &samplerInfo, allocationCallbacks, &textureSampler) != VK_SUCCESS) {
            VD_LOG_ERROR("Could not create image sampler");
            return false;
        }
        return true;
    }

    bool App::initializeTextureImageView() {
        textureImageView = createImageView(vulkanTextureImage->getVkImage(), VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_ASPECT_COLOR_BIT, mipLevels);
        if (!textureImageView) {
            VD_LOG_ERROR("Could not create Vulkan texture image view");
            return false;
        }
        return true;
    }

    VkImageView App::createImageView(VkImage image, VkFormat format, VkImageAspectFlags aspectFlags, uint32_t mipLevels) {
        VkImageViewCreateInfo viewInfo{};
        viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
        viewInfo.image = image;
        viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
        viewInfo.format = format;
        viewInfo.subresourceRange.aspectMask = aspectFlags;
        viewInfo.subresourceRange.baseMipLevel = 0;
        viewInfo.subresourceRange.levelCount = mipLevels;
        viewInfo.subresourceRange.baseArrayLayer = 0;
        viewInfo.subresourceRange.layerCount = 1;

        VkImageView imageView;
        if (vkCreateImageView(vulkanDevice->getDevice(), &viewInfo, nullptr, &imageView) != VK_SUCCESS) {
            VD_LOG_ERROR("Could not create Vulkan image view");
            return nullptr;
        }
        return imageView;
    }

    bool App::initializeTextureImage() {

        /*
         * Load image texels
         */

        // int width;
        // int height;
        // int channels;
        // int desiredChannels = STBI_rgb_alpha;
        // stbi_uc* pixels = stbi_load(TEXTURE_PATH.c_str(), &width, &height, &channels, desiredChannels);
        // if (!pixels) {
        //     VD_LOG_ERROR("Could not load texture image");
        //     return false;
        // }

        /*
         * This calculates the number of levels in the mip chain.
         * - The max function selects the largest dimension.
         * - The log2 function calculates how many times that dimension can be divided by 2.
         * - The floor function handles cases where the largest dimension is not a power of 2.
         * - 1 is added so that the original image has a mip level.
         */
        // mipLevels = ((uint32_t) std::floor(std::log2(std::max(width, height)))) + 1;

        /*
         * Copy image texels to staging buffer
         */

        VkDeviceSize imageSize = 0;//width * height * desiredChannels;
        GPUBuffer stagingBuffer(vulkanPhysicalDevice, vulkanDevice);

        GPUBuffer::Config stagingBufferConfig{};
        stagingBufferConfig.Size = imageSize;
        stagingBufferConfig.Usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
        stagingBufferConfig.MemoryProperties = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;

        if (!stagingBuffer.initialize(stagingBufferConfig)) {
            VD_LOG_ERROR("Could not initialize texture image stagingBuffer");
            return false;
        }

        // stagingBuffer.setData(pixels);
        // stbi_image_free(pixels);

        /*
         * Copy image texels from staging buffer to image
         */

        GPUImage::Config textureImageConfig{};
        // textureImageConfig.Width = width;
        // textureImageConfig.Height = height;
        textureImageConfig.Usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
        textureImageConfig.Format = VK_FORMAT_R8G8B8A8_SRGB;
        textureImageConfig.Tiling = VK_IMAGE_TILING_OPTIMAL;
        textureImageConfig.MemoryProperties = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
        textureImageConfig.Layout = VK_IMAGE_LAYOUT_UNDEFINED;
        textureImageConfig.MipLevels = mipLevels;
        textureImageConfig.SampleCount = VK_SAMPLE_COUNT_1_BIT;

        if (!vulkanTextureImage->initialize(textureImageConfig)) {
            VD_LOG_ERROR("Could not initialize texture image");
            return false;
        }

        VkImage textureImage = vulkanTextureImage->getVkImage();
        if (!transitionImageLayout(textureImage, textureImageConfig.Format, textureImageConfig.Layout, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, textureImageConfig.MipLevels)) {
            VD_LOG_ERROR("Could not transition image layout from undefined to transfer destination");
            return false;
        }
        // copyBufferToImage(stagingBuffer.getVkBuffer(), textureImage, (uint32_t) width, (uint32_t) height);
        stagingBuffer.terminate();

        // if (!generateMipmaps(textureImage, VK_FORMAT_R8G8B8A8_SRGB, width, height, mipLevels)) {
        //     VD_LOG_ERROR("Could not generate mipmaps for texture image");
        //     return false;
        // }

        VD_LOG_INFO("Initialized texture image");
        return true;
    }

    bool App::generateMipmaps(VkImage image, VkFormat imageFormat, int32_t texWidth, int32_t texHeight, uint32_t mipLevels) const {

        // Check if image format supports linear blitting
        VkFormatProperties formatProperties;
        vkGetPhysicalDeviceFormatProperties(vulkanPhysicalDevice->getPhysicalDevice(), imageFormat, &formatProperties);
        if (!(formatProperties.optimalTilingFeatures & VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT)) {
            VD_LOG_ERROR("Image format does not support linear blitting");
            return false;
        }

        VkCommandBuffer commandBuffer = beginSingleTimeCommands();

        VkImageMemoryBarrier barrier{};
        barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
        barrier.image = image;
        barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        barrier.subresourceRange.baseArrayLayer = 0;
        barrier.subresourceRange.layerCount = 1;
        barrier.subresourceRange.levelCount = 1;

        int32_t mipWidth = texWidth;
        int32_t mipHeight = texHeight;

        constexpr VkDependencyFlags dependencyFlags = 0;
        constexpr uint32_t memoryBarrierCount = 0;
        constexpr VkMemoryBarrier* memoryBarriers = VK_NULL_HANDLE;
        constexpr uint32_t bufferMemoryBarrierCount = 0;
        constexpr VkBufferMemoryBarrier* bufferMemoryBarriers = VK_NULL_HANDLE;
        constexpr uint32_t imageMemoryBarrierCount = 1;

        for (uint32_t i = 1; i < mipLevels; i++) {
            barrier.subresourceRange.baseMipLevel = i - 1;
            barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
            barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
            barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
            barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;

            VkPipelineStageFlagBits sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
            VkPipelineStageFlagBits destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
            vkCmdPipelineBarrier(
                    commandBuffer,
                    sourceStage,
                    destinationStage,
                    dependencyFlags,
                    memoryBarrierCount,
                    memoryBarriers,
                    bufferMemoryBarrierCount,
                    bufferMemoryBarriers,
                    imageMemoryBarrierCount,
                    &barrier
            );

            VkImageBlit blit{};
            blit.srcOffsets[0] = { 0, 0, 0 };
            blit.srcOffsets[1] = { mipWidth, mipHeight, 1 };
            blit.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
            blit.srcSubresource.mipLevel = i - 1;
            blit.srcSubresource.baseArrayLayer = 0;
            blit.srcSubresource.layerCount = 1;
            blit.dstOffsets[0] = { 0, 0, 0 };
            blit.dstOffsets[1] = { mipWidth > 1 ? mipWidth / 2 : 1, mipHeight > 1 ? mipHeight / 2 : 1, 1 };
            blit.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
            blit.dstSubresource.mipLevel = i;
            blit.dstSubresource.baseArrayLayer = 0;
            blit.dstSubresource.layerCount = 1;

            VkImageLayout srcImageLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
            VkImageLayout dstImageLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
            VkFilter filter = VK_FILTER_LINEAR;
            constexpr uint32_t regionCount = 1;
            vkCmdBlitImage(
                    commandBuffer,
                    image,
                    srcImageLayout,
                    image,
                    dstImageLayout,
                    regionCount,
                    &blit,
                    filter
            );

            barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
            barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
            barrier.srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
            barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

            sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
            destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
            vkCmdPipelineBarrier(
                    commandBuffer,
                    sourceStage,
                    destinationStage,
                    dependencyFlags,
                    memoryBarrierCount,
                    memoryBarriers,
                    bufferMemoryBarrierCount,
                    bufferMemoryBarriers,
                    imageMemoryBarrierCount,
                    &barrier
            );

            if (mipWidth > 1) {
                mipWidth /= 2;
            }
            if (mipHeight > 1) {
                mipHeight /= 2;
            }
        }

        barrier.subresourceRange.baseMipLevel = mipLevels - 1;
        barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
        barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

        VkPipelineStageFlagBits sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
        VkPipelineStageFlagBits destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
        vkCmdPipelineBarrier(
                commandBuffer,
                sourceStage,
                destinationStage,
                dependencyFlags,
                memoryBarrierCount,
                memoryBarriers,
                bufferMemoryBarrierCount,
                bufferMemoryBarriers,
                imageMemoryBarrierCount,
                &barrier
        );

        endSingleTimeCommands(commandBuffer);
        return true;
    }

    bool App::transitionImageLayout(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout, uint32_t mipLevels) const {
        VkCommandBuffer commandBuffer = beginSingleTimeCommands();

        VkImageMemoryBarrier imageMemoryBarrier{};
        imageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
        imageMemoryBarrier.oldLayout = oldLayout;
        imageMemoryBarrier.newLayout = newLayout;
        imageMemoryBarrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        imageMemoryBarrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        imageMemoryBarrier.image = image;
        imageMemoryBarrier.srcAccessMask = 0;
        imageMemoryBarrier.dstAccessMask = 0;
        imageMemoryBarrier.subresourceRange.baseMipLevel = 0;
        imageMemoryBarrier.subresourceRange.levelCount = mipLevels;
        imageMemoryBarrier.subresourceRange.baseArrayLayer = 0;
        imageMemoryBarrier.subresourceRange.layerCount = 1;

        if (newLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL) {
            imageMemoryBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;
            if (hasStencilComponent(format)) {
                imageMemoryBarrier.subresourceRange.aspectMask |= VK_IMAGE_ASPECT_STENCIL_BIT;
            }
        } else {
            imageMemoryBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        }

        VkPipelineStageFlags sourceStage;
        VkPipelineStageFlags destinationStage;

        if (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED && newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) {
            imageMemoryBarrier.srcAccessMask = 0;
            imageMemoryBarrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
            sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
            destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
        } else if (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL && newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) {
            imageMemoryBarrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
            imageMemoryBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
            sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
            destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
        } else if (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED && newLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL) {
            imageMemoryBarrier.srcAccessMask = 0;
            imageMemoryBarrier.dstAccessMask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
            sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
            destinationStage = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
        } else {
            VD_LOG_ERROR("Could not transition image layout: Unsupported transition");
            return false;
        }

        constexpr VkDependencyFlags dependencyFlags = 0;
        constexpr uint32_t memoryBarrierCount = 0;
        constexpr VkMemoryBarrier* memoryBarriers = VK_NULL_HANDLE;
        constexpr uint32_t bufferMemoryBarrierCount = 0;
        constexpr VkBufferMemoryBarrier* bufferMemoryBarriers = VK_NULL_HANDLE;
        constexpr uint32_t imageMemoryBarrierCount = 1;
        vkCmdPipelineBarrier(
                commandBuffer,
                sourceStage,
                destinationStage,
                dependencyFlags,
                memoryBarrierCount,
                memoryBarriers,
                bufferMemoryBarrierCount,
                bufferMemoryBarriers,
                imageMemoryBarrierCount,
                &imageMemoryBarrier
        );

        endSingleTimeCommands(commandBuffer);
        return true;
    }

    void App::copyBufferToImage(VkBuffer buffer, VkImage image, uint32_t width, uint32_t height) const {
        VkCommandBuffer commandBuffer = beginSingleTimeCommands();

        VkBufferImageCopy bufferImageCopy{};
        bufferImageCopy.bufferOffset = 0;
        bufferImageCopy.bufferRowLength = 0;
        bufferImageCopy.bufferImageHeight = 0;

        bufferImageCopy.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        bufferImageCopy.imageSubresource.mipLevel = 0;
        bufferImageCopy.imageSubresource.baseArrayLayer = 0;
        bufferImageCopy.imageSubresource.layerCount = 1;

        bufferImageCopy.imageOffset = {0, 0, 0};

        constexpr uint32_t depth = 1;
        bufferImageCopy.imageExtent = {width, height, depth };

        constexpr uint32_t regionCount = 1;
        constexpr VkImageLayout imageLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
        vkCmdCopyBufferToImage(
                commandBuffer,
                buffer,
                image,
                imageLayout,
                regionCount,
                &bufferImageCopy
        );

        endSingleTimeCommands(commandBuffer);
    }

    /*
     * TODO
     *
     * All of the helper functions that submit commands so far have been set up to execute synchronously by waiting for the queue to become idle.
     *
     * For practical applications it is recommended to combine these operations in a single command buffer and execute them asynchronously for higher throughput,
     * especially the transitions and copy in the createTextureImage function.
     *
     * Try to experiment with this by creating a setupCommandBuffer that the helper functions record commands into,
     * and add a flushSetupCommands to execute the commands that have been recorded so far.
     *
     * It's best to do this after the texture mapping works to check if the texture resources are still set up correctly.
     */
    VkCommandBuffer App::beginSingleTimeCommands() const {
        VkCommandBufferAllocateInfo allocInfo{};
        allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        allocInfo.commandPool = vulkanCommandPool->getVkCommandPool();
        allocInfo.commandBufferCount = 1;

        VkCommandBuffer commandBuffer;
        vkAllocateCommandBuffers(vulkanDevice->getDevice(), &allocInfo, &commandBuffer);

        VkCommandBufferBeginInfo beginInfo{};
        beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

        vkBeginCommandBuffer(commandBuffer, &beginInfo);
        return commandBuffer;
    }

    void App::endSingleTimeCommands(VkCommandBuffer commandBuffer) const {
        vkEndCommandBuffer(commandBuffer);

        VkSubmitInfo submitInfo{};
        submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
        submitInfo.commandBufferCount = 1;
        submitInfo.pCommandBuffers = &commandBuffer;

        VkFence fence = VK_NULL_HANDLE;
        constexpr uint32_t submitCount = 1;
        vkQueueSubmit(vulkanDevice->getGraphicsQueue(), submitCount, &submitInfo, fence);
        vkQueueWaitIdle(vulkanDevice->getGraphicsQueue());

        vkFreeCommandBuffers(vulkanDevice->getDevice(), vulkanCommandPool->getVkCommandPool(), submitInfo.commandBufferCount, &commandBuffer);
    }

    bool App::initializeUniformBuffers() {
        for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
            GPUUniformBuffer uniformBuffer(vulkanPhysicalDevice, vulkanDevice);
            if (!uniformBuffer.initialize(sizeof(CameraUniform))) {
                VD_LOG_ERROR("Could not initialize uniform buffer for frame [{}]", i);
                return false;
            }
            uniformBuffers.push_back(uniformBuffer);
        }
        VD_LOG_INFO("Initialized [{}] Vulkan uniform buffers", uniformBuffers.size());
        return true;
    }

    bool App::initializeDescriptorSetLayout() {
        VkDescriptorSetLayoutBinding uboLayoutBinding{};
        uboLayoutBinding.binding = 0;
        uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        uboLayoutBinding.descriptorCount = 1;
        uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;

        VkDescriptorSetLayoutBinding samplerLayoutBinding{};
        samplerLayoutBinding.binding = 1;
        samplerLayoutBinding.descriptorCount = 1;
        samplerLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        samplerLayoutBinding.pImmutableSamplers = nullptr;
        samplerLayoutBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;

        std::array<VkDescriptorSetLayoutBinding, 2> bindings = {uboLayoutBinding, samplerLayoutBinding};
        VkDescriptorSetLayoutCreateInfo layoutInfo{};
        layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
        layoutInfo.bindingCount = static_cast<uint32_t>(bindings.size());
        layoutInfo.pBindings = bindings.data();

        constexpr VkAllocationCallbacks* allocationCallbacks = VK_NULL_HANDLE;
        if (vkCreateDescriptorSetLayout(vulkanDevice->getDevice(), &layoutInfo, allocationCallbacks, &descriptorSetLayout) != VK_SUCCESS) {
            VD_LOG_ERROR("Could not create uniform buffer descrptor set layout");
            return false;
        }
        return true;
    }

    bool App::initializeDescriptorPool() {
        std::array<VkDescriptorPoolSize, 2> poolSizes{};
        poolSizes[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        poolSizes[0].descriptorCount = MAX_FRAMES_IN_FLIGHT;
        poolSizes[1].type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        poolSizes[1].descriptorCount = MAX_FRAMES_IN_FLIGHT;

        VkDescriptorPoolCreateInfo poolInfo{};
        poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
        poolInfo.poolSizeCount = (uint32_t) poolSizes.size();
        poolInfo.pPoolSizes = poolSizes.data();
        poolInfo.maxSets = MAX_FRAMES_IN_FLIGHT;

        /*
         * Inadequate descriptor pools are a good example of a problem that the validation layers will not catch:
         * As of Vulkan 1.1, vkAllocateDescriptorSets may fail with the error code VK_ERROR_POOL_OUT_OF_MEMORY if the pool is not sufficiently large,
         * but the driver may also try to solve the problem internally.
         *
         * This means that sometimes (depending on hardware, pool size and allocation size) the driver will let us get away with an allocation that exceeds the limits of our descriptor pool.
         * Other times, vkAllocateDescriptorSets will fail and return VK_ERROR_POOL_OUT_OF_MEMORY.
         *
         * This can be particularly frustrating if the allocation succeeds on some machines, but fails on others.
         */
        constexpr VkAllocationCallbacks* allocationCallbacks = VK_NULL_HANDLE;
        if (vkCreateDescriptorPool(vulkanDevice->getDevice(), &poolInfo, allocationCallbacks, &descriptorPool) != VK_SUCCESS) {
            VD_LOG_ERROR("Could not initialize descriptor pool");
            return false;
        }

        VD_LOG_INFO("Initialized descriptor pool");
        return true;
    }

    bool App::initializeDescriptorSets() {
        std::vector<VkDescriptorSetLayout> layouts(MAX_FRAMES_IN_FLIGHT, descriptorSetLayout);

        VkDescriptorSetAllocateInfo allocInfo{};
        allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
        allocInfo.descriptorPool = descriptorPool;
        allocInfo.descriptorSetCount = MAX_FRAMES_IN_FLIGHT;
        allocInfo.pSetLayouts = layouts.data();

        descriptorSets.resize(MAX_FRAMES_IN_FLIGHT);
        if (vkAllocateDescriptorSets(vulkanDevice->getDevice(), &allocInfo, descriptorSets.data()) != VK_SUCCESS) {
            VD_LOG_ERROR("Could not allocate [{}] descriptor sets", allocInfo.descriptorSetCount);
            return false;
        }

        for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
            const GPUUniformBuffer& uniformBuffer = uniformBuffers[i];

            VkDescriptorBufferInfo bufferInfo{};
            bufferInfo.buffer = uniformBuffer.getBuffer().getVkBuffer();
            bufferInfo.offset = 0;
            bufferInfo.range = sizeof(CameraUniform);

            VkDescriptorImageInfo imageInfo{};
            imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
            imageInfo.imageView = textureImageView;
            imageInfo.sampler = textureSampler;

            std::array<VkWriteDescriptorSet, 2> descriptorWrites{};

            descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
            descriptorWrites[0].dstSet = descriptorSets[i];
            descriptorWrites[0].dstBinding = 0;
            descriptorWrites[0].dstArrayElement = 0;
            descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
            descriptorWrites[0].descriptorCount = 1;
            descriptorWrites[0].pBufferInfo = &bufferInfo;

            descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
            descriptorWrites[1].dstSet = descriptorSets[i];
            descriptorWrites[1].dstBinding = 1;
            descriptorWrites[1].dstArrayElement = 0;
            descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
            descriptorWrites[1].descriptorCount = 1;
            descriptorWrites[1].pImageInfo = &imageInfo;

            auto descriptorWriteCount = (uint32_t) descriptorWrites.size();
            constexpr uint32_t descriptorCopyCount = 0;
            constexpr VkCopyDescriptorSet* descriptorCopies = nullptr;
            vkUpdateDescriptorSets(vulkanDevice->getDevice(), descriptorWriteCount, descriptorWrites.data(), descriptorCopyCount, descriptorCopies);
        }

        VD_LOG_INFO("Initialized descriptor sets");
        return true;
    }

    bool App::initializeRenderingObjects() {
        if (!vulkanSwapChain->initialize()) {
            VD_LOG_ERROR("Could not initialize Vulkan swap chain");
            return false;
        }
        if (!vulkanRenderPass->initialize()) {
            VD_LOG_ERROR("Could not initialize Vulkan render pass");
            return false;
        }
        if (!vulkanGraphicsPipeline->initialize(*vertexShader, *fragmentShader, descriptorSetLayout)) {
            VD_LOG_ERROR("Could not initialize Vulkan graphics pipeline");
            return false;
        }
        if (!initializeColorResources()) {
            VD_LOG_ERROR("Could not initialize color resources");
            return false;
        }
        if (!initializeDepthResources()) {
            VD_LOG_ERROR("Could not initialize depth resources");
            return false;
        }
        if (!initializeFramebuffers()) {
            VD_LOG_ERROR("Could not initialize Vulkan framebuffers");
            return false;
        }
        return true;
    }

    bool App::initializeFramebuffers() {
        for (VkImageView swapChainImageView : vulkanSwapChain->getImageViews()) {
            GPUFramebuffer framebuffer(vulkanDevice, vulkanSwapChain, vulkanRenderPass);
            if (!framebuffer.initialize(colorImageView, depthImageView, swapChainImageView)) {
                VD_LOG_ERROR("Could not initialize framebuffers");
                return false;
            }
            framebuffers.push_back(framebuffer);
        }
        VD_LOG_INFO("Created [{}] Vulkan framebuffers", framebuffers.size());
        return true;
    }

    bool App::initializeSyncObjects() {
        imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
        renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
        inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);

        VkSemaphoreCreateInfo semaphoreInfo{};
        semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

        VkFenceCreateInfo fenceInfo{};
        fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
        fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;

        VkAllocationCallbacks* allocationCallbacks = VK_NULL_HANDLE;
        for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
            if (vkCreateSemaphore(vulkanDevice->getDevice(), &semaphoreInfo, allocationCallbacks, &imageAvailableSemaphores[i]) != VK_SUCCESS) {
                VD_LOG_ERROR("Could not create 'image available' semaphore for frame [{}]", i);
                return false;
            }
            if (vkCreateSemaphore(vulkanDevice->getDevice(), &semaphoreInfo, allocationCallbacks, &renderFinishedSemaphores[i]) != VK_SUCCESS) {
                VD_LOG_ERROR("Could not create 'render finished' semaphore for frame [{}]", i);
                return false;
            }
            if (vkCreateFence(vulkanDevice->getDevice(), &fenceInfo, allocationCallbacks, &inFlightFences[i]) != VK_SUCCESS) {
                VD_LOG_ERROR("Could not create 'in flight' fence for frame [{}]", i);
                return false;
            }
        }
        VD_LOG_INFO("Created Vulkan sync objects (semaphores & fences)");
        return true;
    }

    void App::terminate() {
        VD_LOG_INFO("Terminating...");
        VkAllocationCallbacks* allocationCallbacks = VK_NULL_HANDLE;

        terminateSyncObjects();
        terminateRenderingObjects();

        vkDestroyDescriptorPool(vulkanDevice->getDevice(), descriptorPool, allocationCallbacks);
        vkDestroyDescriptorSetLayout(vulkanDevice->getDevice(), descriptorSetLayout, allocationCallbacks);

        terminateUniformBuffers();

        vulkanIndexBuffer->terminate();
        vulkanVertexBuffer->terminate();
        fragmentShader->terminate();
        vertexShader->terminate();

        vkDestroySampler(vulkanDevice->getDevice(), textureSampler, allocationCallbacks);
        vkDestroyImageView(vulkanDevice->getDevice(), textureImageView, allocationCallbacks);
        vulkanTextureImage->terminate();

        vulkanCommandPool->terminate();
        vulkanDevice->terminate();
        vulkan->terminate();
        window->terminate();
    }

    void App::terminateUniformBuffers() {
        for (GPUUniformBuffer& uniformBuffer : uniformBuffers) {
            uniformBuffer.terminate();
        }
        VD_LOG_INFO("Terminated Vulkan uniform buffers");
    }

    void App::terminateSyncObjects() const {
        VkAllocationCallbacks* allocationCallbacks = VK_NULL_HANDLE;
        for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
            vkDestroySemaphore(vulkanDevice->getDevice(), renderFinishedSemaphores[i], allocationCallbacks);
            vkDestroySemaphore(vulkanDevice->getDevice(), imageAvailableSemaphores[i], allocationCallbacks);
            vkDestroyFence(vulkanDevice->getDevice(), inFlightFences[i], allocationCallbacks);
        }
        VD_LOG_INFO("Destroyed Vulkan sync objects (semaphores & fences)");
    }

    void App::terminateRenderingObjects() {
        terminateFramebuffers();
        terminateDepthResources();
        terminateColorResources();
        vulkanGraphicsPipeline->terminate();
        vulkanRenderPass->terminate();
        vulkanSwapChain->terminate();
    }

    void App::terminateColorResources() {
        VkAllocationCallbacks* allocationCallbacks = VK_NULL_HANDLE;
        vkDestroyImageView(vulkanDevice->getDevice(), colorImageView, allocationCallbacks);
        vulkanColorImage->terminate();
    }

    void App::terminateDepthResources() {
        VkAllocationCallbacks* allocationCallbacks = VK_NULL_HANDLE;
        vkDestroyImageView(vulkanDevice->getDevice(), depthImageView, allocationCallbacks);
        vulkanDepthImage->terminate();
    }

    void App::terminateFramebuffers() {
        for (GPUFramebuffer framebuffer : framebuffers) {
            framebuffer.terminate();
        }
        framebuffers.clear();
        VD_LOG_INFO("Destroyed Vulkan framebuffers");
    }

    bool App::recreateRenderingObjects() {
        window->waitUntilNotMinimized();
        vulkanDevice->waitUntilIdle();
        terminateRenderingObjects();
        vulkanPhysicalDevice->updateSwapChainInfo();
        return initializeRenderingObjects();
    }

    void App::drawFrame() {

        /*
         * Frame acquisition
         */

        // Wait until the previous frame has finished
        constexpr uint32_t fenceCount = 1;
        constexpr VkBool32 waitForAllFences = VK_TRUE;
        constexpr uint64_t waitForFenceTimeout = UINT64_MAX;
        VkFence inFlightFence = inFlightFences[currentFrame];
        vkWaitForFences(vulkanDevice->getDevice(), fenceCount, &inFlightFence, waitForAllFences, waitForFenceTimeout);

        // Acquire an image from the swap chain
        uint32_t swapChainImageIndex;
        VkFence acquireNextImageFence = VK_NULL_HANDLE;
        constexpr uint64_t acquireNextImageTimeout = UINT64_MAX;
        VkSemaphore imageAvailableSemaphore = imageAvailableSemaphores[currentFrame];
        VkResult acquireNextImageResult = vkAcquireNextImageKHR(
                vulkanDevice->getDevice(),
                vulkanSwapChain->getSwapChain(),
                acquireNextImageTimeout,
                imageAvailableSemaphore,
                acquireNextImageFence,
                &swapChainImageIndex
        );
        // VK_ERROR_OUT_OF_DATE_KHR: The swap chain has become incompatible with the surface and can no longer be used for rendering. Usually happens after a window resize.
        if (acquireNextImageResult == VK_ERROR_OUT_OF_DATE_KHR) {
            recreateRenderingObjects();
            return;
        }
        // VK_SUBOPTIMAL_KHR: The swap chain can still be used to successfully present to the surface, but the surface properties are no longer matched exactly.
        if (acquireNextImageResult != VK_SUCCESS && acquireNextImageResult != VK_SUBOPTIMAL_KHR) {
            VD_LOG_CRITICAL("Could not acquire swap chain image");
            throw std::runtime_error("Could not acquire swap chain image");
        }

        // After waiting, we need to manually reset the fence to the unsignaled state
        vkResetFences(vulkanDevice->getDevice(), fenceCount, &inFlightFence);

        /*
         * Command recording
         */

        const GPUCommandBuffer& vulkanCommandBuffer = vulkanCommandBuffers[currentFrame];
        vulkanCommandBuffer.reset();
        vulkanCommandBuffer.begin();

        vulkanRenderPass->begin(vulkanCommandBuffer, framebuffers.at(swapChainImageIndex));
        vulkanGraphicsPipeline->bind(vulkanCommandBuffer);

        VkBuffer vertexBuffers[] = {vulkanVertexBuffer->getGPUBuffer().getVkBuffer()};
        VkDeviceSize vertexBufferOffsets[] = {0};
        constexpr uint32_t firstBinding = 0;
        constexpr uint32_t bindingCount = 1;
        vkCmdBindVertexBuffers(vulkanCommandBuffer.getVkCommandBuffer(), firstBinding, bindingCount, vertexBuffers, vertexBufferOffsets);

        constexpr VkDeviceSize indexBufferOffset = 0;
        constexpr VkIndexType indexType = VK_INDEX_TYPE_UINT32;
        vkCmdBindIndexBuffer(vulkanCommandBuffer.getVkCommandBuffer(), vulkanIndexBuffer->getGPUBuffer().getVkBuffer(), indexBufferOffset, indexType);

        VkDescriptorSet descriptorSet = descriptorSets[currentFrame];
        VkPipelineBindPoint pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
        VkPipelineLayout pipelineLayout = vulkanGraphicsPipeline->getPipelineLayout();
        constexpr uint32_t firstSet = 0;
        constexpr uint32_t descriptorSetCount = 1;
        constexpr uint32_t dynamicOffsetCount = 0;
        constexpr uint32_t* dynamicOffsets = nullptr;
        vkCmdBindDescriptorSets(vulkanCommandBuffer.getVkCommandBuffer(), pipelineBindPoint, pipelineLayout, firstSet, descriptorSetCount, &descriptorSet, dynamicOffsetCount, dynamicOffsets);

        constexpr uint32_t instanceCount = 1;
        constexpr uint32_t firstVertex = 0;
        constexpr int32_t vertexOffset = 0;
        constexpr uint32_t firstInstance = 0;
        vkCmdDrawIndexed(vulkanCommandBuffer.getVkCommandBuffer(), (uint32_t) indices.size(), instanceCount, firstVertex, vertexOffset, firstInstance);

        vulkanRenderPass->end(vulkanCommandBuffer);

        if (!vulkanCommandBuffer.end()) {
            VD_LOG_CRITICAL("Could not end frame");
            throw std::runtime_error("Could not end frame");
        }

        /*
         * Command submission
         */

        VkSubmitInfo submitInfo{};
        submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

        VkCommandBuffer vkCommandBuffer = vulkanCommandBuffer.getVkCommandBuffer();
        submitInfo.pCommandBuffers = &vkCommandBuffer;
        submitInfo.commandBufferCount = 1;

        // Wait with writing colors to the image until it's available
        VkSemaphore waitSemaphores[] = {imageAvailableSemaphore};
        VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};
        submitInfo.pWaitSemaphores = waitSemaphores;
        submitInfo.pWaitDstStageMask = waitStages;
        submitInfo.waitSemaphoreCount = 1;

        // Which semaphores to signal once the command buffer(s) have finished execution
        VkSemaphore renderFinishedSemaphore = renderFinishedSemaphores[currentFrame];
        VkSemaphore signalSemaphores[] = {renderFinishedSemaphore};
        submitInfo.pSignalSemaphores = signalSemaphores;
        submitInfo.signalSemaphoreCount = 1;

        // Submit recorded graphics commands
        constexpr uint32_t submitCount = 1;
        if (vkQueueSubmit(vulkanDevice->getGraphicsQueue(), submitCount, &submitInfo, inFlightFence) != VK_SUCCESS) {
            VD_LOG_CRITICAL("Could not submit to graphics queue");
            throw std::runtime_error("Could not submit to graphics queue");
        }

        /*
         * Frame presentation
         */

        VkPresentInfoKHR presentInfo{};
        presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;

        // Which semaphores to wait on before presentation can happen
        presentInfo.pWaitSemaphores = signalSemaphores;
        presentInfo.waitSemaphoreCount = 1;

        // Which swap chain to present image to
        VkSwapchainKHR swapChains[] = {vulkanSwapChain->getSwapChain()};
        presentInfo.pSwapchains = swapChains;
        presentInfo.pImageIndices = &swapChainImageIndex;
        presentInfo.swapchainCount = 1;

        // Present image to swap chain
        VkResult presentResult = vkQueuePresentKHR(vulkanDevice->getPresentQueue(), &presentInfo);
        if (presentResult == VK_ERROR_OUT_OF_DATE_KHR || presentResult == VK_SUBOPTIMAL_KHR || windowResized) {
            windowResized = false;
            recreateRenderingObjects();
        } else if (presentResult != VK_SUCCESS) {
            VD_LOG_CRITICAL("Could not present image to swap chain");
            throw std::runtime_error("Could not present image to swap chain");
        }

        currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
    }

    void App::update() {
        static auto startTime = std::chrono::high_resolution_clock::now();

        auto currentTime = std::chrono::high_resolution_clock::now();
        float time = std::chrono::duration<float, std::chrono::seconds::period>(currentTime - startTime).count();

        CameraUniform cameraUniform{};

        // auto modelTransform = Matrix4(1.0f);
        // float rotationAngle = time * glm::radians(90.0f);
        // auto rotationAxis = Vector3(0.0f, 0.0f, 1.0f);
        // cameraUniform.model = glm::rotate(modelTransform, rotationAngle, rotationAxis);

        // auto eyeTransform = Vector3(2.0f, 2.0f, 2.0f);
        // auto centerTransform = Vector3(0.0f, 0.0f, 0.0f);
        // auto upAxis = Vector3(0.0f, 0.0f, 1.0f);
        // cameraUniform.view = glm::lookAt(eyeTransform, centerTransform, upAxis);

        // float fieldOfView = glm::radians(45.0f);
        // float aspectRatio = (float) vulkanSwapChain->getExtent().width / (float) vulkanSwapChain->getExtent().height;
        // float nearViewPlane = 0.1f;
        // float farViewPlane = 10.0f;
        // cameraUniform.projection = glm::perspective(fieldOfView, aspectRatio, nearViewPlane, farViewPlane);

        // /*
        //  * GLM was originally designed for OpenGL, where the Y coordinate of the clip coordinates is inverted.
        //  * The easiest way to compensate for that is to flip the sign on the scaling factor of the Y rotationAxis in the projection matrix.
        //  * If we don't do this, then the image will be rendered upside down.
        //  *
        //  * This change causes the vertices to be drawn in counter-clockwise order instead of clockwise order.
        //  * This causes backface culling to kick in and prevents any geometry from being drawn.
        //  * To fix this the graphics pipeline's rasterization state should have a counter clockwise front-facing triangle orientation to be used for culling.
        //  *
        //  * VkPipelineRasterizationStateCreateInfo rasterizationState{};
        //  * rasterizationState.cullMode = VK_CULL_MODE_BACK_BIT;
        //  * rasterizationState.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
        //  */
        // cameraUniform.projection[1][1] *= -1;

        // const GPUUniformBuffer& uniformBuffer = uniformBuffers[currentFrame];
        // uniformBuffer.setData((void*) &cameraUniform);
    }

}