#include "App.h"
#include "Log.h"

#include <vulkan/vulkan.h>

// The glm/gtc/matrix_transform.hpp header exposes functions that can be used to generate model transformations like glm::rotate, view transformations like glm::lookAt and projection transformations like glm::perspective.
// The GLM_FORCE_RADIANS definition is necessary to make sure that functions like glm::rotate use radians as arguments, to avoid any possible confusion.
// #define GLM_FORCE_RADIANS

// The perspective projection matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default.
// We need to configure it to use the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition.
// #define GLM_FORCE_DEPTH_ZERO_TO_ONE

// #include <glm/glm.hpp>
// #include <glm/gtc/matrix_transform.hpp>

// #define STB_IMAGE_IMPLEMENTATION
// #include <stb_image.h>

#define TINYOBJLOADER_IMPLEMENTATION
// #include <tiny_obj_loader.h>

#include <chrono>
#include <unordered_map>

namespace GPUAPI {

    const uint32_t MAX_FRAMES_IN_FLIGHT = 2;

    App::App(Config config)
            : config(std::move(config)),
              fileSystem(new FileSystem),
              vertexShader(new GPUShader(vulkanDevice)),
              fragmentShader(new GPUShader(vulkanDevice)),
              vulkanIndexBuffer(new GPUIndexBuffer(vulkanPhysicalDevice, vulkanDevice, vulkanCommandPool)),
          }

    App::~App() {
        delete vulkanIndexBuffer;
        delete fragmentShader;
        delete vertexShader;
        delete window;
        delete fileSystem;
    }

    void App::run() {
        if (!initialize()) {
            VD_LOG_CRITICAL("Could not initialize app");
            return;
        }
        VD_LOG_INFO("Running...");
        // while (!window->shouldClose()) {
        //     window->pollEvents();
        //     update();
        //     drawFrame();
        // }
        vulkanDevice->waitUntilIdle();
        terminate();
    }

    bool App::initialize() {
        // Log::initialize(config.Name, config.LogLevel);
        VD_LOG_INFO("Initializing...");


        if (!vertexShader->initialize(fileSystem->readBytes("shaders/simple_shader.vert.spv"))) {
            VD_LOG_ERROR("Could not initialize vertex shader");
            return false;
        }
        if (!fragmentShader->initialize(fileSystem->readBytes("shaders/simple_shader.frag.spv"))) {
            VD_LOG_ERROR("Could not initialize fragment shader");
            return false;
        }
 
        if (!vulkanIndexBuffer->initialize(indices)) {
            VD_LOG_ERROR("Could not initialize Vulkan index buffer");
            return false;
        }

        return true;
    }

    void App::terminate() {
        VD_LOG_INFO("Terminating...");
        VkAllocationCallbacks* allocationCallbacks = VK_NULL_HANDLE;

        vkDestroyDescriptorPool(vulkanDevice->getDevice(), descriptorPool, allocationCallbacks);
        vkDestroyDescriptorSetLayout(vulkanDevice->getDevice(), descriptorSetLayout, allocationCallbacks);

        vulkanIndexBuffer->terminate();
        fragmentShader->terminate();
        vertexShader->terminate();
        window->terminate();
    }

    void App::drawFrame() {

        // /*
        //  * Frame acquisition
        //  */

        // // Wait until the previous frame has finished
        // constexpr uint32_t fenceCount = 1;
        // constexpr VkBool32 waitForAllFences = VK_TRUE;
        // constexpr uint64_t waitForFenceTimeout = UINT64_MAX;
        // VkFence inFlightFence = inFlightFences[currentFrame];
        // vkWaitForFences(vulkanDevice->getDevice(), fenceCount, &inFlightFence, waitForAllFences, waitForFenceTimeout);

        // // Acquire an image from the swap chain
        // uint32_t swapChainImageIndex;
        // VkFence acquireNextImageFence = VK_NULL_HANDLE;
        // constexpr uint64_t acquireNextImageTimeout = UINT64_MAX;
        // VkSemaphore imageAvailableSemaphore = imageAvailableSemaphores[currentFrame];
        // VkResult acquireNextImageResult = vkAcquireNextImageKHR(
        //         vulkanDevice->getDevice(),
        //         vulkanSwapChain->getSwapChain(),
        //         acquireNextImageTimeout,
        //         imageAvailableSemaphore,
        //         acquireNextImageFence,
        //         &swapChainImageIndex
        // );
        // // VK_ERROR_OUT_OF_DATE_KHR: The swap chain has become incompatible with the surface and can no longer be used for rendering. Usually happens after a window resize.
        // if (acquireNextImageResult == VK_ERROR_OUT_OF_DATE_KHR) {
        //     // recreateRenderingObjects();
        //     return;
        // }
        // // VK_SUBOPTIMAL_KHR: The swap chain can still be used to successfully present to the surface, but the surface properties are no longer matched exactly.
        // if (acquireNextImageResult != VK_SUCCESS && acquireNextImageResult != VK_SUBOPTIMAL_KHR) {
        //     VD_LOG_CRITICAL("Could not acquire swap chain image");
        //     throw std::runtime_error("Could not acquire swap chain image");
        // }

        // // After waiting, we need to manually reset the fence to the unsignaled state
        // vkResetFences(vulkanDevice->getDevice(), fenceCount, &inFlightFence);

        /*
         * Command recording
         */

        const GPUCommandBuffer& vulkanCommandBuffer = vulkanCommandBuffers[currentFrame];
        vulkanCommandBuffer.reset();
        vulkanCommandBuffer.begin();

        vulkanRenderPass->begin(vulkanCommandBuffer, framebuffers.at(swapChainImageIndex));
        vulkanGraphicsPipeline->bind(vulkanCommandBuffer);

        VkBuffer vertexBuffers[] = {vulkanVertexBuffer->getGPUBuffer().getVkBuffer()};
        VkDeviceSize vertexBufferOffsets[] = {0};
        constexpr uint32_t firstBinding = 0;
        constexpr uint32_t bindingCount = 1;
        vkCmdBindVertexBuffers(vulkanCommandBuffer.getVkCommandBuffer(), firstBinding, bindingCount, vertexBuffers, vertexBufferOffsets);

        constexpr VkDeviceSize indexBufferOffset = 0;
        constexpr VkIndexType indexType = VK_INDEX_TYPE_UINT32;
        vkCmdBindIndexBuffer(vulkanCommandBuffer.getVkCommandBuffer(), vulkanIndexBuffer->getGPUBuffer().getVkBuffer(), indexBufferOffset, indexType);

        VkDescriptorSet descriptorSet = descriptorSets[currentFrame];
        VkPipelineBindPoint pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
        VkPipelineLayout pipelineLayout = vulkanGraphicsPipeline->getPipelineLayout();
        constexpr uint32_t firstSet = 0;
        constexpr uint32_t descriptorSetCount = 1;
        constexpr uint32_t dynamicOffsetCount = 0;
        constexpr uint32_t* dynamicOffsets = nullptr;
        vkCmdBindDescriptorSets(vulkanCommandBuffer.getVkCommandBuffer(), pipelineBindPoint, pipelineLayout, firstSet, descriptorSetCount, &descriptorSet, dynamicOffsetCount, dynamicOffsets);

        constexpr uint32_t instanceCount = 1;
        constexpr uint32_t firstVertex = 0;
        constexpr int32_t vertexOffset = 0;
        constexpr uint32_t firstInstance = 0;
        vkCmdDrawIndexed(vulkanCommandBuffer.getVkCommandBuffer(), (uint32_t) indices.size(), instanceCount, firstVertex, vertexOffset, firstInstance);

        vulkanRenderPass->end(vulkanCommandBuffer);

        if (!vulkanCommandBuffer.end()) {
            VD_LOG_CRITICAL("Could not end frame");
            throw std::runtime_error("Could not end frame");
        }

        /*
         * Command submission
         */

        VkSubmitInfo submitInfo{};
        submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

        VkCommandBuffer vkCommandBuffer = vulkanCommandBuffer.getVkCommandBuffer();
        submitInfo.pCommandBuffers = &vkCommandBuffer;
        submitInfo.commandBufferCount = 1;

        // Wait with writing colors to the image until it's available
        VkSemaphore waitSemaphores[] = {imageAvailableSemaphore};
        VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};
        submitInfo.pWaitSemaphores = waitSemaphores;
        submitInfo.pWaitDstStageMask = waitStages;
        submitInfo.waitSemaphoreCount = 1;

        // Which semaphores to signal once the command buffer(s) have finished execution
        VkSemaphore renderFinishedSemaphore = renderFinishedSemaphores[currentFrame];
        VkSemaphore signalSemaphores[] = {renderFinishedSemaphore};
        submitInfo.pSignalSemaphores = signalSemaphores;
        submitInfo.signalSemaphoreCount = 1;

        // Submit recorded graphics commands
        constexpr uint32_t submitCount = 1;
        if (vkQueueSubmit(vulkanDevice->getGraphicsQueue(), submitCount, &submitInfo, inFlightFence) != VK_SUCCESS) {
            VD_LOG_CRITICAL("Could not submit to graphics queue");
            throw std::runtime_error("Could not submit to graphics queue");
        }

        /*
         * Frame presentation
         */

        VkPresentInfoKHR presentInfo{};
        presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;

        // Which semaphores to wait on before presentation can happen
        presentInfo.pWaitSemaphores = signalSemaphores;
        presentInfo.waitSemaphoreCount = 1;

        // Which swap chain to present image to
        VkSwapchainKHR swapChains[] = {vulkanSwapChain->getSwapChain()};
        presentInfo.pSwapchains = swapChains;
        presentInfo.pImageIndices = &swapChainImageIndex;
        presentInfo.swapchainCount = 1;

        // Present image to swap chain
        VkResult presentResult = vkQueuePresentKHR(vulkanDevice->getPresentQueue(), &presentInfo);
        if (presentResult == VK_ERROR_OUT_OF_DATE_KHR || presentResult == VK_SUBOPTIMAL_KHR || windowResized) {
            windowResized = false;
            // recreateRenderingObjects();
        } else if (presentResult != VK_SUCCESS) {
            VD_LOG_CRITICAL("Could not present image to swap chain");
            throw std::runtime_error("Could not present image to swap chain");
        }

        currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
    }

    void App::update() {
        static auto startTime = std::chrono::high_resolution_clock::now();

        auto currentTime = std::chrono::high_resolution_clock::now();
        float time = std::chrono::duration<float, std::chrono::seconds::period>(currentTime - startTime).count();

        CameraUniform cameraUniform{};

        // auto modelTransform = Matrix4(1.0f);
        // float rotationAngle = time * glm::radians(90.0f);
        // auto rotationAxis = Vector3(0.0f, 0.0f, 1.0f);
        // cameraUniform.model = glm::rotate(modelTransform, rotationAngle, rotationAxis);

        // auto eyeTransform = Vector3(2.0f, 2.0f, 2.0f);
        // auto centerTransform = Vector3(0.0f, 0.0f, 0.0f);
        // auto upAxis = Vector3(0.0f, 0.0f, 1.0f);
        // cameraUniform.view = glm::lookAt(eyeTransform, centerTransform, upAxis);

        // float fieldOfView = glm::radians(45.0f);
        // float aspectRatio = (float) vulkanSwapChain->getExtent().width / (float) vulkanSwapChain->getExtent().height;
        // float nearViewPlane = 0.1f;
        // float farViewPlane = 10.0f;
        // cameraUniform.projection = glm::perspective(fieldOfView, aspectRatio, nearViewPlane, farViewPlane);

        // /*
        //  * GLM was originally designed for OpenGL, where the Y coordinate of the clip coordinates is inverted.
        //  * The easiest way to compensate for that is to flip the sign on the scaling factor of the Y rotationAxis in the projection matrix.
        //  * If we don't do this, then the image will be rendered upside down.
        //  *
        //  * This change causes the vertices to be drawn in counter-clockwise order instead of clockwise order.
        //  * This causes backface culling to kick in and prevents any geometry from being drawn.
        //  * To fix this the graphics pipeline's rasterization state should have a counter clockwise front-facing triangle orientation to be used for culling.
        //  *
        //  * VkPipelineRasterizationStateCreateInfo rasterizationState{};
        //  * rasterizationState.cullMode = VK_CULL_MODE_BACK_BIT;
        //  * rasterizationState.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
        //  */
        // cameraUniform.projection[1][1] *= -1;

        // const GPUUniformBuffer& uniformBuffer = uniformBuffers[currentFrame];
        // uniformBuffer.setData((void*) &cameraUniform);
    }

}